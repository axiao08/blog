<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[具有缓存功能的类(Integer、Long等)]]></title>
    <url>%2Fblog%2Fpost%2F1e4f1b6.html</url>
    <content type="text"><![CDATA[地址：https://www.cnblogs.com/rouqinglangzi/p/8848607.htmlInteger类的缓存机制我们查看Integer的源码，就会发现里面有个静态内部类。1234567891011121314151617181920212223242526272829303132333435363738public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; //当前值在缓存数组区间段，则直接返回该缓存值 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; //否则创建新的Integer实例 return new Integer(i);&#125; private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; //IntegerCache初始化时，缓存数值为-128-127的Integer实例(默认是从-128到127)。 static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; //填充缓存数组 for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125;&#125;该类的作用是将数值等于-128-127(默认)区间的Integer实例缓存到cache数组中。通过valueOf()方法很明显发现，当再次创建值在-128-127区间的Integer实例时，会复用缓存中的实例，也就是直接指向缓存中的Integer实例。(注意：这里的创建不包括用new创建，new创建对象不会复用缓存实例)其它具有缓存机制的类实际上不仅仅Integer具有缓存机制，Byte、Short、Long、Character都具有缓存机制。来看看Long类中的缓存类12345678910private static class LongCache &#123; private LongCache()&#123;&#125; static final Long cache[] = new Long[-(-128) + 127 + 1]; static &#123; for(int i = 0; i &lt; cache.length; i++) cache[i] = new Long(i - 128); &#125;&#125;ByteCache用于缓存Byte对象，ShortCache用于缓存Short对象，LongCache用于缓存Long对象，CharacterCache用于缓存Character对象。这些类都有缓存的范围，其中Byte，Short，Integer，Long为 -128 到 127，Character范围为 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。总结具有缓存机制的类Byte、Short、Integer、Long、Character都具有缓存机制。缓存工作都是在静态块中完成，在类生命周期（loading verify prepare resolving initial using unload）的初始化阶段执行。缓存范围Byte，Short，Integer，Long为 -128 到 127，Character范围为 0 到 127改变缓存范围除了Integer可以指定缓存范围，其它类都不行。Integer的缓存上界high可以通过jvm参数-XX:AutoBoxCacheMax=size指定，取指定值与127的最大值并且不超过Integer表示范围，而下界low不能指定，只能为-128。]]></content>
      <categories>
        <category>Java 基础知识</category>
      </categories>
      <tags>
        <tag>自动拆装箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础数据类型、不能用浮点数表示金额]]></title>
    <url>%2Fblog%2Fpost%2Fb5696b25.html</url>
    <content type="text"><![CDATA[java 的基本数据类型关系图不能用浮点数来表示金额精度丢失问题从上面我们可以知道，float的精度是23位，double精度是63位。在存储或运算过程中，当超出精度时，超出部分会被截掉，由此就会造成误差。对于金额而言，舍去不能表示的部分，损失也就产生了。进制转换误差从上面我们可以知道，在计算机实际处理和运算过程中，浮点数本质上是以二进制形式存在的。而十进制的0.1在二进制下将是一个无限循环小数，这就会导致误差的出现。如果一个小数不是2的负整数次幂，用浮点数表示必然产生浮点误差。换言之：A进制下的有限小数，转换到B进制下极有可能是无限小数，误差也由此产生。浮点数不精确的根本原因在于：尾数部分的位数是固定的，一旦需要表示的数字的精度高于浮点数的精度，那么必然产生误差！解决这个问题的方法是BigDecimal的类，这个类可以表示任意精度的数字，其原理是：用字符串存储数字，转换为数组来模拟大数，实现两个数组的数学运算并将结果返回。BigDecimal的使用要点BigDecimal变量初始化——必须用传入String的构造方法12BigDecimal num1 = new BigDecimal(0.005);//用数值转换成大数，有误差BigDecimal num12 = new BigDecimal(&quot;0.005&quot;);//用字符串转换成大数，无误差因为：不是所有的浮点数都能够被精确的表示成一个double 类型值，有些浮点数值不能够被精确的表示成 double 类型值时，它会被表示成与它最接近的 double 类型的值，此时用它来初始化一个大数，会“先造成了误差，再用产生了误差的值生成大数”，也就是“将错就错”。使用除法函数在divide的时候要设置各种参数，要精确的小数位数和舍入模式，其中有8种舍入模式：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801、ROUND_UP远离零的舍入模式。在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。注意，此舍入模式始终不会减少计算值的大小。2、ROUND_DOWN接近零的舍入模式。在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。注意，此舍入模式始终不会增加计算值的大小。3、ROUND_CEILING接近正无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同;如果为负，则舍入行为与 ROUND_DOWN 相同。注意，此舍入模式始终不会减少计算值。4、ROUND_FLOOR接近负无穷大的舍入模式。如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同;如果为负，则舍入行为与 ROUND_UP 相同。注意，此舍入模式始终不会增加计算值。5、ROUND_HALF_UP向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。6、ROUND_HALF_DOWN向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。7、ROUND_HALF_EVEN向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。如果前一位为奇数，则入位，否则舍去。以下例子为保留小数点1位，那么这种舍入方式下的结果。1.15&gt;1.2 1.25&gt;1.28、ROUND_UNNECESSARY断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。]]></content>
      <categories>
        <category>Java 基础知识</category>
      </categories>
      <tags>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat蓝绿部署脚本]]></title>
    <url>%2Fblog%2Fpost%2F145f84f8.html</url>
    <content type="text"><![CDATA[适用于两个tomcat的情况，例如：/home/xiao/tomcat/hgd_tomcat8011/home/xiao/tomcat/hgd_tomcat8012使用如下命令执行脚本:重启hgd_tomcat8011：1./restart_hgdTomcat.sh -n 1重启hgd_tomcat8012：1./restart_hgdTomcat.sh -n 2restart_hgdTomcat.sh 如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/bin/bash #参数arg=&quot;&quot;#tomcat路径tomcat_path=&quot;&quot; while getopts &quot;:n:&quot; opt; do case $opt in n) arg=$OPTARG ;; \?) exit 1 ;; esac done if [[ -n &quot;$arg&quot; &amp;&amp; &quot;$arg&quot; == 1 ]];then tomcat_path=&quot;hgd_tomcat8011&quot;elif [[ -n &quot;$arg&quot; &amp;&amp; &quot;$arg&quot; == 2 ]];then tomcat_path=&quot;hgd_tomcat8012&quot;fiif [[ -n &quot;$tomcat_path&quot; ]];then # 获取tomcat进程id tomcat_id=`ps -ef |grep &quot;$tomcat_path&quot; | grep -v grep | awk &apos;&#123;print $2&#125;&apos;` echo &quot;进程id为：$tomcat_id&quot; #杀进程 for id in $tomcat_id do kill -9 $id done echo &quot;killed $tomcat_id&quot; echo &quot;拷贝war包到tomcat webapps下&quot; cp -f -v ROOT.war /home/xiao/tomcat/$tomcat_path/webapps echo &quot;拷贝war包完毕&quot; echo &quot;删除项目目录&quot; rm -rf /home/xiao/tomcat/$tomcat_path/webapps/ROOT echo &quot;已删项目目录，开始重启tomcat&quot; /home/xiao/tomcat/$tomcat_path/bin/startup.sh echo &quot;查看tomcat启动日志&quot; tail -f /home/xiao/tomcat/$tomcat_path/logs/catalina.out fi]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>蓝绿部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux主机不能解析域名]]></title>
    <url>%2Fblog%2Fpost%2F8c0da5bf.html</url>
    <content type="text"><![CDATA[不能解析域名，windows可以ping通，而Linux不能，究其原因 dns的问题。解决方法1vim /etc/resolv.conf添加一行1nameserver 223.6.6.6保存后重启网络服务1service network restart如果问题没解决尝试以下修改1vim /etc/nsswitch.conf12hosts: files dnsnetworks: files改成12hosts: files dns winsnetworks: files阿里DNS12223.5.5.5 223.6.6.6]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java代码优化]]></title>
    <url>%2Fblog%2Fpost%2Fd30f66d6.html</url>
    <content type="text"><![CDATA[前言优化代码的目标是：减小代码的体积提高代码运行的效率本文的内容有些来自网络，有些来自平时工作和学习。尽量在适合的场景使用单例使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有的地方都适用于单例，简单来说，单例主要适用于以下三个方面：控制资源的使用，通过线程同步来控制资源的并发访问；控制实例的产生，以达到节约资源的目的；控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。尽量避免随意使用静态变量当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如123public class A &#123; private static B b = new B();&#125;此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。尽量避免过多过常地创建Java对象尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大的重用对象，最好能用基本的数据类型或数组来替代对象。尽量指定类、方法的final修饰符带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。及时关闭流Java编译过程中，进行数据库连接、I/O流操作是务必小心，在使用完毕后，及时关闭并释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。尽量减少对变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。例如如下的操作：1for(int i = 0; i &lt; list.size(); i++) &#123;&#125;建议替换成:1for(int i = 0, len = list.size(); i &lt; len; i++) &#123;&#125;这样，在list.size()很大的时候，就减少了很多的消耗尽量采用懒加载的策略，即在需要的时候才创建例如：1234String str = &quot;abc&quot;;if(i == 1) &#123; list.add(str);&#125;建议替换为：1234if(i == 1) &#123; String str = &quot;abc&quot;; list.add(str);&#125;慎用异常异常对性能不利。抛出异常首先要创建一个新的对象。Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。使用system.arraycopy()代替通过来循环复制数组system.arraycopy()要比通过循环来复制数组快的多。例如：123456789101112public class irb &#123; void method () &#123; int[] array1 = new int [100]; for (int i = 0; i &lt; array1.length; i++) &#123; array1 [i] = i; &#125; int[] array2 = new int [100]; for (int i = 0; i &lt; array2.length; i++) &#123; array2 [i] = array1 [i]; &#125; &#125;&#125;更正为：12345678910public class irb &#123; void method () &#123; int[] array1 = new int [100]; for (int i = 0; i &lt; array1.length; i++) &#123; array1 [i] = i; &#125; int[] array2 = new int [100]; system.arraycopy(array1, 0, array2, 0, 100); &#125;&#125;如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：StringBuilder() // 默认分配16个字符的空间StringBuilder(int size) // 默认分配size个字符的空间StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间把原来的4096个字符拷贝到新的的字符数组中去这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。乘法和除法使用移为操作例如：1234for (val = 0; val &lt; 100000; val += 5) &#123; a = val * 8; b = val / 2;&#125;用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：1234for (val = 0; val &lt; 100000; val += 5) &#123; a = val &lt;&lt; 3; b = val &gt;&gt; 1;&#125;移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。循环内不要不断创建对象引用例如：for (int i = 1; i &lt;= count; i++) {Object obj = new Object();}这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：1234Object obj = null;for (int i = 0; i &lt;= count; i++) &#123; obj = new Object();&#125;这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销不要将数组声明为public static final因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：123456if (list instanceof RandomAccess) &#123; for (int i = 0; i &lt; list.size(); i++)&#123;&#125;&#125; else &#123; Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext())&#123;iterator.next()&#125;&#125;]]></content>
      <categories>
        <category>Java性能优化</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目中常用的19条MySQL优化]]></title>
    <url>%2Fblog%2Fpost%2F378a71fe.html</url>
    <content type="text"><![CDATA[作者：zhangqh地址：segmentfault.com/a/1190000012155267本文总结了19条关于Mysql的优化方案，本文的优化方案都是基于 “ Mysql-索引-BTree类型 ” 的。希望对你有帮助。一、EXPLAIN做MySQL优化，我们要善用 EXPLAIN 查看SQL执行计划。下面来个简单的示例，标注(1,2,3,4,5)我们要重点关注的数据type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式key_len列，索引长度rows列，扫描行数。该值是个预估值extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary二、SQL语句中IN包含的值不应过多MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from table_name where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。三、SELECT语句务必指明字段名称SELECT *增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。四、当只需要一条数据的时候，使用limit 1这是为了使EXPLAIN中type列达到const类型五、如果排序字段没有用到索引，就尽量少排序六、如果限制条件中其他字段没有索引，尽量少用oror两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果七、尽量用union all代替unionunion和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。八、不使用ORDER BY RAND()12select id from table_name order by rand() limit 1000;上面的sql语句，可优化为12select id from table_name t1 join (select rand() * (select max(id) from `table_name`) asnid) t2 on t1.id &gt; t2.nid limit 1000;九、区分in和exists， not in和not exists12select * from 表A where id in (select id from 表B)上面sql语句相当于12select * from 表A where exists(select * from 表B where 表B.id=表A.id)区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。如何高效的写出一个替代not exists的sql语句？原sql语句12select colname … from A表 where a.id not in (select b.id from B表)高效的sql语句12select colname … from A表 Left join B表 on where a.id = b.id where b.id is null取出的结果集如下图表示，A表不在B表中的数据十、使用合理的分页方式以提高分页的效率12select id,name from table_name limit 866613, 20使用上述sql语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：12select id,name from table_name where id&gt; 866612 limit 20十一、分段查询在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。如下图这个sql语句，扫描的行数成百万级以上的时候就可以使用分段查询十二、避免在 where 子句中对字段进行 null 值判断对于null的判断会导致引擎放弃使用索引而进行全表扫描。十三、不建议使用%前缀模糊查询例如LIKE “%name”或者LIKE “%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。那如何查询%name%？如下图所示，虽然给secret字段添加了索引，但在explain结果果并没有使用那么如何解决这个问题呢，答案：使用全文索引在我们查询中经常会用到select id,fnum,fdst from table_name where user_name like ‘%zhangsan%’; 。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。创建全文索引的sql语法是：12ALTER TABLE `table_name` ADD FULLTEXT INDEX `idx_user_name` (`user_name`);使用全文索引的sql语句是：12select id,fnum,fdst from table_name where match(user_name) against(&apos;zhangsan&apos; in booleanmode);注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别十四、避免在where子句中对字段进行表达式操作比如12select user_id,user_project from table_name where age*2=36;中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成12select user_id,user_project from table_name where age=36/2;十五、避免隐式类型转换where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型十六、对于联合索引来说，要遵守最左前缀法则举列来说索引含有字段id,name,school，可以直接用id字段，也可以id,name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面十七、必要时可以使用force index来强制查询走某个索引有的时候MySQL优化器采取它认为合适的索引来检索sql语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用force index来强制优化器使用我们制定的索引。十八、注意范围查询语句对于联合索引来说，如果存在范围查询，比如between,&gt;,&lt;等条件时，会造成后面的索引字段失效。十九、关于JOIN优化LEFT JOIN A表为驱动表INNER JOIN MySQL会自动找出那个数据少的表作用驱动表RIGHT JOIN B表为驱动表注意：MySQL中没有full join，可以用以下方式来解决1234select * from A left join B on B.name = A.name where B.name is nullunion allselect * from B;尽量使用inner join，避免left join参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表。合理利用索引被驱动表的索引字段作为on的限制字段。利用小表去驱动大表从原理图能够直观的看出如果能够减少驱动表的话，减少嵌套循环中的循环次数，以减少 IO总量及CPU运算的次数。巧用STRAIGHT_JOINinner join是由mysql选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。STRAIGHT_JOIN来强制连接顺序，在STRAIGHT_JOIN左边的表名就是驱动表，右边则是被驱动表。在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是inner join。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。这个方式有时可能减少3倍的时间。这里只列举了上述优化方案，当然还有其他的优化方式，大家可以去摸索尝试，感谢关注。]]></content>
      <categories>
        <category>MySQL优化</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
